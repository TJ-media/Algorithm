# -*- coding: utf-8 -*-
"""분할정복_최대구간합구하기.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ylb_hq36U7V0NhnlEWw6-yA4wMWldYQ6
"""

def max_sum(A, left, right):
	# A[left], ..., A[right] 중 최대 구간 합 리턴
	if left == right:
		return A[left]
	if len(A) == 0:
		return 'array is empty'
	if len(A) == 1:
		return A[0]

	m = (left + right) // 2
	left_sum = 0
	right_sum = 0
	left_max = -1000      #최소값으로 초기화
	right_max = 0
	real_max = 0

	for i in range(m, left - 1, -1):
		left_sum += A[i]
		left_max = max(left_max, left_sum)
	for j in range(m + 1, right + 1):
		right_sum += A[j]
		right_max = max(right_max, right_sum)

	real_max = left_max + right_max

	result = max(max_sum(A, left, m), max_sum(A, m+1, right))
	result = max(result, real_max)
	return result

A = [int(x) for x in input().split()]
sol = max_sum(A, 0, len(A)-1)
print(sol)

#알고리즘 설명
#주어진 리스트 범위에서 index의 중앙값 m을 기준으로 세 가지 경우로 나눈다.
#최대구간합이 A[m]을 포함한다면 그 값을 구하고 return한다. m을 기준으로 양쪽으로 각각 n/2개의 값을 더하고 비교하므로 Cn의 수행시간이 걸린다.
#최대구간합이 A[m]을 포함하지 않는다면 m의 양쪽 절반 중에 존재하므로 양쪽 절반에서 재귀적으로 최대구간합을 찾는다.

#T(n)의 점화식과 최종 수행시간
#최대구간합이 A[m]을 포함한다고 가정했을 때 그 값을 구하는데 O(n)시간이 걸린다.
#그리고 최대구간합이 A[m]을 포함하지 않는다고 가정했을 때 왼쪽 구간 오른쪽 구간으로 나누어 재귀적으로 최대구간합을 찾으므로 점화식 T(n) = 2T(n/2) + Cn이다.
#따라서 최종 수행시간은 O(nlogn)이다.
#최대구간합이 어디에 존재할 지는 마지막까지 비교해봐야 알 수 있기 때문에 이 알고리즘은 항상 worst case로 O(nlogn)수행시간을 가진다.