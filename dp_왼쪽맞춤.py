# -*- coding: utf-8 -*-
"""DP_왼쪽맞춤.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w8Uy988vf6yX-8t5SiEhiw9S3msEWCIS
"""

W = int(input())
words = input().split()
# code below
n = len(words)
lw = [0]*(n+1)                         #lw == length word // 18,19번 line에서 index error를 피하기 위해 size를 n+1로 설정
for i in range(n):
	lw[i] = (len(words[i]))

dp = [0]*(n+1)                         #18,19번 line에서 index error를 피하기 위해 size를 n+1로 설정
dp[n-1] = (W - lw[n-1])**3             #바닥조건

for j in range(n-2, -1, -1):           #j = n-2, n-3, ...
	ls = W - lw[j]                       #ls : length space
	k = 1
	dp[j] = ls**3 + dp[j + 1]            #dp[j]초기화

	while ls >= 0 and j + k <= n:        #빈칸이 0이상이고, index가 n이하일 때
		sdp = ls**3 + dp[j + k]            #sdp : smallest dp
		ls = ls - lw[j + k] - 1
		k += 1

		if sdp < dp[j]:
			dp[j] = sdp

print(dp[0])


#DP점화식
#dp[x] = min((W - lw[x])**3 + dp[x+1], (W - lw[x] - lw[x+1] - 1)**3 + dp[x+2], (W - lw[x] - lw[x+1] - 1 - lw[x+2] - 1)**3 + dp[x+3].....)
#n개의 단어 중 가장 마지막 단어의 penalty값을 dp[n-1]라고 하자. (W - lw[n-1])**3
#마지막 두 단어의 penalty값 중 최소값을 dp[n-2]라고 하자. min((W - lw[n-1])**3 + (W - lw[n-2])**3, (W - lw[n-1] - lw[n-2] - 1)**3)
#x번 째의 단어가 만약 한 줄에 혼자 있다면 그 줄의 penalty는 (W - len[x])**3일 것이다.
#마지막 단어부터 penalty값을 구해왔으므로 x번 째 단어까지의 penalty합은 (W - lw[x])**3 + dp[x+1]가 된다.
#하지만 x번 째 단어와 (x+1)번째 단어가 같은 줄에 있다면 그 때의 penalty합은 (W - lw[x] - lw[x+1] - 1)**3 + dp[x+2]가 된다.
#따라서 dp점화식이 위와 같다.

#수행시간 분석
#dp테이블의 각각의 값을 구하는 시간을 생각하지 않고 단순히 n개의 dp테이블을 채우는데만 O(n)시간이 걸린다. (for문이 n번 돌아감)
#dp테이블의 각 값을 구하는 시간은 최악의 경우 O(n)시간 걸린다. (while문이 최대로 돌아간다고 가정했을 때(1,2,3,....,n-1, n번 돌아감))
#따라서 최악의 경우 O(n) x O(n) = O(n^2)시간이 걸린다.
#하지만 while문의 탈출 조건은 두 가지가 있다.
#만약 W가 충분히 크지 못하다면 탈출 조건 중 ls >=0을 만족시키지 못할 확률이 크다.
#그렇다면(W가 충분히 크지 않다면) while문은 O(n)번 돌아가지 않고 O(0)번 돌아갈 것이다.
#따라서 최악의 경우 O(n^2)이지만 보통의 경우는 O(n)정도의 수행시간을 가질 것이다.