# -*- coding: utf-8 -*-
"""연속해서k번째로작은수찾기.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ci1SSGW7Oa6DkKd_z8GBmaMQo9xzkglo
"""

#heap구조를 사용하여 문제를 해결한다.
#i개의 숫자를 두 리스트로 나눈다.
#가장 작은 (i//3 + 1)개의 숫자가 들어있는 리스트(min_heap리스트) & 나머지 숫자가 들어있는 리스트(max_heap리스트)
#min_heap 리스트는 루트노드가 가장 큰 값이 되도록 heap정렬해준다.
#max_heap 리스트는 루트노드가 가장 작은 값이 되도록 heap정렬해준다.
#각 그룹의 루트노드는 서로 이웃한 숫자이므로, 서로 루트노드를 heappop, heappush 해주며 min_heap리스트의 len이 (i//3 + 1)가 되도록 한다.

import heapq

A = list(map(int,input().split()))

m = [0] * len(A)
min_heap = []
max_heap = []

for i in range(len(A)) :
	if len(min_heap) == 0 or -min_heap[0] > A[i] :
		heapq.heappush(min_heap, -A[i])

	else :
		heapq.heappush(max_heap, A[i])

	if len(min_heap) > i//3 + 1 :
		heapq.heappush(max_heap, -heapq.heappop(min_heap))
	elif len(min_heap) < i//3 + 1 :
		heapq.heappush(min_heap, -heapq.heappop(max_heap))
	m[i]= -min_heap[0]

print(sum(m))

#Big-O분석
#A를 입력받고 for문 전까지는 상수시간
#for문은 n개의 입력에 대해 모두 돌아야하기 때문에 n번 돈다.
#첫 번째 if문은 비교하는데 상수시간, heappush 연산하는데 logn시간 걸린다.
#두 번째 if문은 비교하는데 상수시간, heappop하고 heappush하는데 Clogn시간 걸린다.
#m[i] 저장하는 것도 상수시간, for문 바깥의 print(sum(m))함수도 상수시간 걸린다.
#결국 첫 번째 if문과 두 번째 if문의 수행시간을 단순 합하여 for문의 수행시간을 곱해주어야 하므로, 총 수행시간은 O(nlogn)이다.